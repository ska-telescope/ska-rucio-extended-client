#!/usr/bin/env python

import argparse
import configparser
import logging
import os

from dirhash import dirhash
from rucio.client.didclient import DIDClient

from rucio_extended_client.common.exceptions import ArgumentError, ConfigError, ChecksumVerificationError
from rucio_extended_client.api.plan import DownloadPlanMetadata, DownloadPlanNative


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', help="path to configuration file", default="/usr/local/etc/config.ini", type=str)
    parser.add_argument('-o', help="overwrite existing directory if it exists", action='store_true')
    parser.add_argument('-p', help="path to download plan", type=str)
    parser.add_argument('-v', help="verbose?", action='store_true')
    parser.add_argument('--dry-run', help="dry run?", action='store_true')
    parser.add_argument('--name', help="name", type=str)
    parser.add_argument('--scope', help="scope", type=str)
    parser.add_argument('--skip-checksum', help="skip checksum?", action='store_true')
    args = parser.parse_args()

    if args.v:
        logging.basicConfig(
            level=logging.DEBUG,
            format="%(asctime)s [%(name)s] %(module)10s %(levelname)5s %(process)d\t%(message)s")
    else:
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s [%(name)s] %(module)10s %(levelname)5s %(process)d\t%(message)s")

    if not args.c or not os.path.isfile(args.c):
        raise ArgumentError("Configuration file has not been set or does not exist")

    if args.p:
        if not os.path.isfile(args.p):
            raise ArgumentError("Plan given but path does not exist")
    else:
        if not args.scope:
            raise ArgumentError("scope has not been set")
        if not args.name:
            raise ArgumentError("scope has not been set")

    config = configparser.ConfigParser()
    config.read(args.c)
    try:
        metadata_plugin = config['general']['METADATA_PLUGIN']
        hierarchy_key = config['hierarchy']['METADATA_KEY']
        method = config['hierarchy']['METHOD'].lower()
        common_kwargs = {
            'hierarchy_key': hierarchy_key
        }
        if method == 'native':
            download_plan_cls = DownloadPlanNative
            download_plan_kwargs = {
                'fallback_root_suffix': config['hierarchy.native']['ROOT_SUFFIX'],
                'fallback_path_delimiter': config['hierarchy.native']['PATH_DELIMITER'],
                **common_kwargs
            }
        elif method == 'metadata':
            download_plan_cls = DownloadPlanMetadata
            download_plan_kwargs = {
                **common_kwargs
            }
        else:
            raise UnknownMethod("method {} is not understood".format(method))
    except KeyError as e:
        raise ConfigError("Key {} does not exist".format(e))

    # either load or make plan
    if args.p:
        plan = download_plan_cls.load(args.p)
    else:
        plan = download_plan_cls.make_plan_from_did(
            root_container_scope=args.scope, root_container_name=args.name, metadata_plugin=metadata_plugin,
            clobber=args.o, show_tree=True, **download_plan_kwargs)

    plan.describe()
    plan.run(dry_run=args.dry_run)

    # Verify directory checksum if requested.
    if not args.skip_checksum and not args.dry_run:
        # Get metadata of root container
        did_client = DIDClient()
        metadata = did_client.get_metadata(scope=args.scope, name=args.name, plugin=metadata_plugin)

        # Check for dir_checksum key
        if 'dir_checksum' in metadata[hierarchy_key]:
            logging.info("dir_checksum key found in metadata")
            dir_checksum = metadata[hierarchy_key]['dir_checksum']
            if dir_checksum is None:
                logging.warning("dir_checksum is Nonetype, skipping checksum verification")
            else:
                logging.info("verifying checksum")
                this_dir_checksum = dirhash(args.name, algorithm='md5', empty_dirs=True)
                try:
                    assert dir_checksum == this_dir_checksum
                except AssertionError as e:
                    logging.critical("Checksum verification failed")
                    raise ChecksumVerificationError("Directory checksum does not match: {}!={}".format(
                        dir_checksum, this_dir_checksum))
                logging.info("Checksum verification passed")
        else:
            logging.warning("dir_checksum not in container metadata, skipping checksum verification")
